// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_BASE_RUNTIME_H
#define _ASMJIT_BASE_RUNTIME_H

// [Dependencies - AsmJit]
#include "../base/error.h"

// [Api-Begin]
#include "../apibegin.h"

namespace asmjit {

// ============================================================================
// [Forward Declarations]
// ============================================================================

struct BaseAssembler;
struct BaseCpuInfo;
struct MemoryManager;

// ============================================================================
// [asmjit::BaseRuntime]
// ============================================================================

//! @brief Base runtime.
struct BaseRuntime {
  ASMJIT_NO_COPY(BaseRuntime)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a @ref BaseRuntime instance.
  ASMJIT_API BaseRuntime();
  //! @brief Destroy the @ref BaseRuntime instance.
  ASMJIT_API virtual ~BaseRuntime();

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  //! @brief Get stack alignment of target runtime.
  virtual uint32_t getStackAlignment() = 0;

  //! @brief Get CPU information.
  virtual const BaseCpuInfo* getCpuInfo() = 0;

  //! @brief Allocate memory for code generated in @a assembler and reloc it
  //! to the target location.
  //!
  //! This method is universal allowing any preprocessing / postprocessing
  //! with code generated by @ref BaseAssembler or @ref BaseCompiler. Because
  //! @ref BaseCompiler always uses @ref BaseAssembler it's allowed to access
  //! only the @ref BaseAssembler instance.
  //!
  //! This method is always last step when using code generation. You can use
  //! it to allocate memory for JIT code, saving code to remote process or a
  //! file.
  //!
  //! @retrurn Status code, see @ref kError.
  virtual Error add(void** dst, BaseAssembler* assembler) = 0;

  //! @brief Release memory allocated by add.
  virtual Error release(void* p) = 0;
};

// ============================================================================
// [asmjit::JitRuntime]
// ============================================================================

//! @brief JIT runtime.
struct JitRuntime : public BaseRuntime {
  ASMJIT_NO_COPY(JitRuntime)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a @c JitRuntime instance.
  ASMJIT_API JitRuntime(MemoryManager* memmgr = NULL);
  //! @brief Destroy the @c JitRuntime instance.
  ASMJIT_API virtual ~JitRuntime();

  // --------------------------------------------------------------------------
  // [Memory Manager and Alloc Type]
  // --------------------------------------------------------------------------

  // Note: These members can be ignored by all derived classes. They are here
  // only to privide default implementation. All other implementations (remote
  // code patching or making dynamic loadable libraries/executables) ignore
  // members accessed by these accessors.

  //! @brief Get the @c MemoryManager instance.
  ASMJIT_INLINE MemoryManager* getMemoryManager() const { return _memoryManager; }

  //! @brief Get the type of allocation.
  ASMJIT_INLINE uint32_t getAllocType() const { return _allocType; }
  //! @brief Set the type of allocation.
  ASMJIT_INLINE void setAllocType(uint32_t allocType) { _allocType = allocType; }

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  ASMJIT_API virtual uint32_t getStackAlignment();
  ASMJIT_API virtual const BaseCpuInfo* getCpuInfo();

  ASMJIT_API virtual Error add(void** dst, BaseAssembler* assembler);
  ASMJIT_API virtual Error release(void* p);

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Memory manager.
  MemoryManager* _memoryManager;
  //! @brief Type of allocation.
  uint32_t _allocType;
};

} // asmjit namespace

// [Api-End]
#include "../apiend.h"

// [Guard]
#endif // _ASMJIT_BASE_RUNTIME_H
